1. Which classes are aggregates of other classes? Checking all constructors of whole classes if they
initialize for their parts?
- CompactDisc chứa ArrayList<Track>	
- Book chứa List<String> authors	
- Cart chứa ArrayList<Media>	
- Store chứa ArrayList<Media>
Xoá các setter dư thừa:
Những phương thức setter nên xóa bỏ nếu:
Dữ liệu không thay đổi sau khi tạo (ví dụ: title, cost, id, category, director, length)
Để đảm bảo tính bất biến (immutable) cho đối tượng
Chỉ giữ lại các phương thức add/remove như trong CompactDisc (addTrack, removeTrack) hoặc Book (addAuthor, removeAuthor) là đủ.
2. If the passing object is not an instance of Media, what happens?
Khi ta viết
```
if (!(o instanceof Media)) return false;
```
Thì trình biên dịch sẽ tránh lỗi ClassCastException, giúp chương trình an toàn hơn. 
Nếu không kiểm tra, khi ta ép kiểu ((Media) o) mà o không phải Media, thì sẽ bị runtime error.
3. What class should implement the Comparable interface?
Lớp Media nên implements interface Comparable<Media>, vì Media là lớp cha chung cho các loại đối tượng như Book, DigitalVideoDisc, CompactDisc. 
Khi đó, ta có thể định nghĩa quy tắc sắp xếp mặc định cho mọi loại Media.
4. How should you implement the compareTo() method to reflect the ordering we want?
Nếu ta muốn quy tắc sắp xếp mặc định là:
Sắp xếp theo title (thứ tự alphabet), nếu trùng thì theo cost giảm dần.
Ta sẽ implement như sau:
```
@Override
public int compareTo(Media other) {
    int titleCompare = this.getTitle().compareToIgnoreCase(other.getTitle());
    if (titleCompare != 0) {
        return titleCompare;
    } else {
        return Float.compare(other.getCost(), this.getCost()); // giảm dần theo cost
    }
}
```
5. Can we have two ordering rules (by title then cost and by cost then title) using Comparable?
=> Ta không thể.
Giao diện Comparable chỉ cho phép một quy tắc so sánh duy nhất vì nó chỉ có một phương thức compareTo().
Nếu bạn cần nhiều quy tắc sắp xếp (ví dụ: lúc thì theo title, lúc thì theo cost), bạn nên sử dụng Comparator thay vì Comparable.
Vì vậy:
- Comparable → 1 quy tắc mặc định.
- Comparator → Nhiều quy tắc tùy ý.
6. Suppose the DVDs have a different ordering rule (by title, then decreasing length, then cost). How would you modify your code?
Ta có thể override phương thức compareTo() riêng trong lớp con DigitalVideoDisc, ví dụ:
```
public class DigitalVideoDisc extends Media {
    private int length;

    @Override
    public int compareTo(Media other) {
        if (!(other instanceof DigitalVideoDisc)) {
            return super.compareTo(other); // fallback to Media's compareTo
        }

        DigitalVideoDisc o = (DigitalVideoDisc) other;
        int titleCompare = this.getTitle().compareToIgnoreCase(o.getTitle());
        if (titleCompare != 0) return titleCompare;

        int lengthCompare = Integer.compare(o.length, this.length); // length giảm dần
        if (lengthCompare != 0) return lengthCompare;

        return Float.compare(this.getCost(), o.getCost()); // cost tăng dần
    }
}
```



